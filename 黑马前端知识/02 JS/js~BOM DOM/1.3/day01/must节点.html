<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
   <div class='demo'>
       <div class="box">
           <sapn class="erweima"></span>   
       </div>
    <div class="box2"></div>
   </div> 
   <button>删除</button>
   <ul class="bb">
           <li>熊大</li>
           <li>熊二</li>
           <li>光头强</li>
       </ul>
       <div class="a1"></div>
    <script>
       //节点操作:
       /*1.DOM的方法获取元素
       document.getElementById()
       document.getElementsByTagName()
       document.querySelector()等
       逻辑性不强，繁琐

       2.节点层次关系获得元素
        利用父子兄点关系获取元素
        逻辑性强，但兼容性稍差
    */

   //1.节点至少拥有nodeType(节点类型).nodeName（节点名称）.nodeValue(节点值)，这三个基本属性
   //元素节点nodeType为1
   //属性节点nodeType为2
   //文本节点nodeType为3(文本节点：文字。空格。换行等)
   //实际开发中，主要使用元素节点；常见父子兄层次关系

/*
    //1.父节点parentNode
    var erweima=document.querySelector('.erweima');
    var box=document.querySelector('.box')
    //得到的是离元素最近的父节点（亲爸爸），若找不到父节点返回null
    console.log(erweima.parentNode);//.box
    console.log(box.parentNode);//.demo

    //2.子节点parentNode.childNodes(标准)----返回值里面包含所以子节点，元素节点、文本节点、属性节点等，，，不提倡使用
        //DOM提供的方法API获取
        var ul=document.querySelector('ul')
        for(var i=0;i<ul.childNodes.length;i++){
            if(ul.childNodes[i].nodeType==1){//得特定条件才可返回元素节点
                console.log(ul.childNodes[i]);
           }
           
        }
        console.log(ul.childNodes[0]);//#test:就是空格属于文本节点
        console.log(ul.childNodes[1]);//li:元素节点
        console.log(ul.childNodes);//获取所有子节点，手机开发常用
       

    //3.第一个子元素和最后一个子元素
    var ul=document.querySelector('ul');
    //1）firstChild第一个子节点，不管是文本节点还是元素节点
    console.log(ul.firstChild);//#test
    console.log(ul.lastChild);//#test
    //2）firstElementchild返回第一个元素节点
        console.log(ul.firstElementChild);//li1
        console.log(ul.lastElementChild);//li3
    //3）实际开发写法，既没有兼容性又返回第一个元素
    console.log(ul.children[0]);//li1
    console.log(ul.children[ul.children.length-1]);//li3
    console.log(ul.children);


     //4.节点层次----下面两种方法都有兼容性，IE9以上支持
        var div=document.querySelector('.box');
        //1)nextSibing下一个兄弟节点 包含元素节点或者 文本节点等
        console.log(div.nextSibling);//#text
        console.log(div.previousSibling);//#text
        //2)nextElementSibing得到下一个兄弟元素节点
        console.log(div.nextElementSibling);//box2
        console.log(div.previousElementSibling);//null

    //5.创建节点(动态创建节点),document.createElement('tarName')，由tarName指定HTML元素
    var li=document.createElement('li');
    
    //6.添加节点，node.appendChild(child):将节点添加到父节点子节点的末尾，相当于after伪元素
    var ul=document.querySelector('ul');
    ul.appendChild(li);
   
    //7.添加节点node.insertBefore(child,指定元素);
    var lili =document.createElement('li');
    ul.insertBefore(lili,ul.children[0])//新元素插入指定位置
   
    //页面添加一个新的元素：1.创建元素；2.添加元素
    //8.删除节点node.removeChild(child)删除一个节点，返回删除的节点
    var ul=document.querySelector('ul')
    var btn=document.querySelector('button');
    btn.onclick=function(){
        if(ul.children.length==0){
            this.disabled=true;
        }
        else{
            ul.removeChild(ul.children[0]);//永远删除第一行
        }
    } 
     

     //9.复制节点（克隆节点）node.cloneNode()；括号参数为空或false,浅拷贝，即只克隆节点本身，不克隆里面的子节点
     //node.clonNode();括号为空或false --浅拷贝，只克隆节点本身，不克隆里面的子节点
     //node.clonNode(true); 深拷贝，复制标签，复制里面的内容
     var ul=document.querySelector('ul');
     var lili=ul.children[0].cloneNode(true);
     var lii=ul.children[0].cloneNode();
     var ii=ul.children[0].cloneNode(false);
     ul.appendChild(lili);
     ul.appendChild(lii);
     ul.appendChild(ii);
     */

     //10.面试重点-----------------------------------------------------------------------------------------------------------------------------------------------
    //三种动态创建元素区别
    //1.document.write():直接把内容写入页面的内容流，但文档流执行完毕
    //2.element.innerHtml：创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂
    var inner =document.querySelector('.a1');
    /*错误的写法，效率极低
    for(var i=0;i<=100;i++){
        inner.innerHTML+='<a href="#"> 百度</a>';
    }
    */
   //正确的写法，效率高
    var arr=[];
    for(var i=0;i<=100;i++){
    arr.push('<a href="#"> 百度</a>');
    }
    inner.innerHTML=arr.join('');
   
    //3.document.createElement()：创建多个元素效率稍微低一点，但结构清晰
    //总结：不同浏览器下，innerHTML效率比createElement高
    //面试题：2.3两个效率谁更高
    var inner =document.querySelector('.a1');
    for(var i=0;i<=100;i++){
    var a=document.createElement('a')
    inner.appendChild(a);
    a.innerHTML='1';
}
    </script>
</body>
</html>